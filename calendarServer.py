#!/usr/bin/env python3
"""
Google Calendar MCP Server (real MCP compliant)
Exposes tools: check_availability, get_schedule
"""
from utils.call_mcp_tool import call_mcp_tool
import asyncio
import argparse
import json

from datetime import datetime
from typing import Dict, List, Any
from fastmcp import FastMCP
from googleapiclient.discovery import build
from google.oauth2.credentials import Credentials

SCOPES = ["https://www.googleapis.com/auth/calendar"]


class GoogleCalendarMCPServer:
    def __init__(self):
        # Load credentials from token.json (generated by setup_google_calendar.py)
        self.creds = Credentials.from_authorized_user_file("token_calendar.json", SCOPES)
        self.service = build("calendar", "v3", credentials=self.creds)
        self.events = self._get_google_events()

    def _get_google_events(self) -> List[Dict[str, Any]]:
        """Fetch upcoming Google Calendar events"""
        now = datetime.utcnow().isoformat() + "Z"
        events_result = (
            self.service.events()
            .list(
                calendarId="primary",
                timeMin=now,
                maxResults=50,
                singleEvents=True,
                orderBy="startTime",
            )
            .execute()
        )
        events = events_result.get("items", [])
        formatted_events = []

        for e in events:
            start = e["start"].get("dateTime", e["start"].get("date"))
            end = e["end"].get("dateTime", e["end"].get("date"))
            date = start.split("T")[0] if "T" in start else start

            try:
                start_dt = datetime.fromisoformat(start.replace("Z", ""))
                end_dt = datetime.fromisoformat(end.replace("Z", ""))
            except Exception:
                continue

            formatted_events.append(
                {
                    "summary": e.get("summary", "No Title"),
                    "start": start_dt,
                    "end": end_dt,
                    "date": date,
                }
            )
        return formatted_events

    def check_availability(self, date: str, time: str = None) -> Dict[str, Any]:
        """Check if user is available on a specific date/time"""
        events_on_date = [e for e in self.events if e["date"] == date]

        if not events_on_date:
            return {
                "available": True,
                "message": f"You are completely free on {date}",
                "events": [],
            }

        if time:
            # Expect "HH:MM" only
            try:
                check_time = datetime.strptime(f"{date} {time}", "%Y-%m-%d %H:%M")
            except ValueError:
                return {
                    "available": False,
                    "message": f"Invalid time format '{time}'. Use HH:MM (e.g. 10:00).",
                    "events": []
                }

            for e in events_on_date:
                # Normalize all datetimes to naive
                start = e["start"].astimezone(tz=None).replace(tzinfo=None)
                end = e["end"].astimezone(tz=None).replace(tzinfo=None)
                check_time = check_time.replace(tzinfo=None)

                if start <= check_time < end:
                    return {
                        "available": False,
                        "message": f"You are busy at {time} on {date} with {e['summary']}",
                        "events": [
                            {
                                "summary": e["summary"],
                                "time": f"{start.strftime('%H:%M')} - {end.strftime('%H:%M')}",
                            }
                        ],
                    }

            return {
                "available": True,
                "message": f"You are free at {time} on {date}",
                "events": [],
            }

        return {
            "available": len(events_on_date) < 8,
            "message": f"You have {len(events_on_date)} event(s) on {date}",
            "events": [
                {
                    "summary": e["summary"],
                    "time": f"{e['start'].strftime('%H:%M')} - {e['end'].strftime('%H:%M')}",
                }
                for e in events_on_date
            ],
        }
        
    def get_schedule(self, date: str) -> Dict[str, Any]:
        """Get full schedule for a specific date"""
        events_on_date = [e for e in self.events if e["date"] == date]
        if not events_on_date:
            return {"date": date, "events": [], "message": f"No events scheduled for {date}"}
        return {
            "date": date,
            "events": [
                {
                    "summary": e["summary"],
                    "start_time": e["start"].strftime("%H:%M"),
                    "end_time": e["end"].strftime("%H:%M"),
                }
                for e in events_on_date
            ],
            "message": f"Found {len(events_on_date)} event(s) on {date}",
        }
    
    def schedule_meeting(self, date: str, start_time: str, end_time: str, summary: str) -> Dict[str, Any]:
        """
        Schedule a new meeting on Google Calendar.
        Args:
            date (str): Date in YYYY-MM-DD
            start_time (str): Start time in HH:MM (24hr)
            end_time (str): End time in HH:MM (24hr)
            summary (str): Meeting title
        """
        try:
            start_dt = datetime.strptime(f"{date} {start_time}", "%Y-%m-%d %H:%M")
            end_dt = datetime.strptime(f"{date} {end_time}", "%Y-%m-%d %H:%M")

            event = {
                "summary": summary,
                "start": {"dateTime": start_dt.isoformat(), "timeZone": "Asia/Kolkata"},
                "end": {"dateTime": end_dt.isoformat(), "timeZone": "Asia/Kolkata"},
            }

            created_event = (
                self.service.events().insert(calendarId="primary", body=event).execute()
            )
            event_link=created_event.get("htmlLink")
            # refresh local cache
            self.events.append({
                "summary": summary,
                "start": start_dt,
                "end": end_dt,
                "date": date,
            })


            return {
                "success": True,
                "message": f"Meeting '{summary}' scheduled on {date} from {start_time} to {end_time}",
                "event_link": event_link,
                

            }
        except Exception as e:
            return {"success": False, "message": f"Failed to schedule meeting: {str(e)}"}


# --------------- MCP Server ---------------- #

calendar_server = GoogleCalendarMCPServer()
server = FastMCP("GoogleCalendarMCP")


@server.tool()
def check_availability(date: str, time: str = None) -> str:
    """Check if the user is available on a specific date (optionally at a time)."""
    return json.dumps(calendar_server.check_availability(date, time), indent=2)


@server.tool()
def get_schedule(date: str) -> str:
    """Get the full schedule for a specific date."""
    return json.dumps(calendar_server.get_schedule(date), indent=2)

@server.tool()
def schedule_meeting(date: str, start_time: str, end_time: str, summary: str) -> str:
    """Book a meeting in the calendar for a given date and time with a title."""
    return json.dumps(calendar_server.schedule_meeting(date, start_time, end_time, summary), indent=2)
# ---------------- Email Tool ---------------- #

@server.tool()
async def send_meeting_email(to: str, subject: str, body: str) -> str:
    """
    Send a meeting invite email via Gmail MCP.
    """
    try:
        result = await call_mcp_tool("gmail_client", "send_email", {
            "to": to,
            "subject": subject,
            "body": body
        })
        return json.dumps(result, indent=2)
    except Exception as e:
        return json.dumps({"success": False, "message": str(e)}, indent=2)

if __name__ == "__main__":
    print("ðŸš€ Starting MCP server...")
    parser = argparse.ArgumentParser()
    parser.add_argument("--server_type", type=str, default="sse", choices=["sse", "stdio"])
    args = parser.parse_args()
    server.run(args.server_type,host="127.0.0.1", port=8080)

